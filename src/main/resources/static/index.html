<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tenable MCP</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-gray-100">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white shadow">
            <div class="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8">
                <h1 class="text-3xl font-bold text-gray-900">Tenable MCP</h1>
            </div>
        </header>

        <!-- Main Content -->
        <main class="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
            <!-- API Configuration Section -->
            <div class="bg-white shadow rounded-lg p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">API Configuration</h2>
                <div class="grid grid-cols-1 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Access Key</label>
                        <input type="password" id="accessKey" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Secret Key</label>
                        <input type="password" id="secretKey" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Base URL</label>
                        <input type="text" id="baseUrl" value="https://cloud.tenable.com" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                    </div>
                    <div class="flex space-x-4">
                        <button onclick="saveConfig()" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                            Save Configuration
                        </button>
                        <button onclick="testConnection()" class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                            Test Connection
                        </button>
                    </div>
                    <!-- Connection Status -->
                    <div id="connectionStatus" class="hidden mt-4 p-4 rounded-md">
                        <div class="flex">
                            <div class="flex-shrink-0">
                                <i id="statusIcon" class="fas"></i>
                            </div>
                            <div class="ml-3">
                                <h3 id="statusTitle" class="text-sm font-medium"></h3>
                                <div id="statusDetails" class="mt-2 text-sm"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Conversation Section -->
            <div class="bg-white shadow rounded-lg p-6 mb-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold">Conversation</h2>
                    <button id="clearConversation" class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        <i class="fas fa-trash mr-2"></i>Clear
                    </button>
                </div>
                <div id="conversationContainer" class="space-y-4 max-h-96 overflow-y-auto mb-4 p-4 bg-gray-50 rounded-lg"></div>
            </div>

            <!-- Query Section -->
            <div class="bg-white shadow rounded-lg p-6">
                <h2 class="text-xl font-semibold mb-4">Ask Tenable</h2>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Your Question</label>
                        <textarea id="queryInput" rows="4" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" placeholder="Ask a question or continue the conversation..."></textarea>
                    </div>
                    <div>
                        <button onclick="askQuestion()" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                            Ask
                        </button>
                    </div>
                </div>

                <!-- Response Section -->
                <div class="mt-6">
                    <h3 class="text-lg font-medium text-gray-900">Response</h3>
                    <div id="responseContainer" class="mt-2 space-y-4">
                        <!-- Loading State -->
                        <div id="loadingState" class="hidden">
                            <div class="flex items-center space-x-2">
                                <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-indigo-600"></div>
                                <span class="text-gray-600">Processing your request...</span>
                            </div>
                            <div class="mt-2">
                                <div class="w-full bg-gray-200 rounded-full h-2">
                                    <div id="loadingProgress" class="bg-indigo-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Response Content -->
                        <div id="responseContent" class="space-y-4">
                            <!-- Data Table Section -->
                            <div id="dataTable" class="overflow-x-auto"></div>

                            <!-- Visualization Section -->
                            <div id="visualization" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div class="bg-white p-4 rounded-lg shadow">
                                    <canvas id="trendChart"></canvas>
                                </div>
                                <div class="bg-white p-4 rounded-lg shadow">
                                    <canvas id="severityChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        let conversationHistory = [];
        let currentContext = {
            lastAction: null,
            filters: {}
        };

        // Initialize Chart.js
        let severityChart = null;
        let trendChart = null;

        // Load current configuration when page loads
        window.onload = function() {
            loadConfig();
        };

        // Load current configuration
        function loadConfig() {
            fetch('/config')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Config data:', data); // Debug log
                    if (data.success) {
                        const config = data.config;
                        const accessKeyInput = document.getElementById('accessKey');
                        const secretKeyInput = document.getElementById('secretKey');
                        const baseUrlInput = document.getElementById('baseUrl');

                        if (accessKeyInput && config.hasAccessKey) {
                            accessKeyInput.value = '********';
                            accessKeyInput.setAttribute('data-has-value', 'true');
                        }
                        if (secretKeyInput && config.hasSecretKey) {
                            secretKeyInput.value = '********';
                            secretKeyInput.setAttribute('data-has-value', 'true');
                        }
                        if (baseUrlInput) {
                            baseUrlInput.value = config.baseUrl || 'https://cloud.tenable.com';
                        }
                    } else {
                        console.error('Failed to load configuration:', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error loading configuration:', error);
                });
        }

        // Save API configuration
        function saveConfig() {
            const accessKeyInput = document.getElementById('accessKey');
            const secretKeyInput = document.getElementById('secretKey');
            const baseUrlInput = document.getElementById('baseUrl');

            // Only send keys if they've been changed (not asterisks)
            const accessKey = accessKeyInput.getAttribute('data-has-value') === 'true' ? null : accessKeyInput.value;
            const secretKey = secretKeyInput.getAttribute('data-has-value') === 'true' ? null : secretKeyInput.value;
            const baseUrl = baseUrlInput.value;

            const configData = {
                baseUrl: baseUrl
            };

            // Only include keys if they've been changed
            if (accessKey) configData.accessKey = accessKey;
            if (secretKey) configData.secretKey = secretKey;

            fetch('/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(configData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    alert('Configuration saved successfully!');
                    loadConfig(); // Reload to show asterisks for saved keys
                } else {
                    alert('Error saving configuration: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error saving configuration. Please try again.');
            });
        }

        // Test connection to Tenable.io
        function testConnection() {
            const statusDiv = document.getElementById('connectionStatus');
            const statusIcon = document.getElementById('statusIcon');
            const statusTitle = document.getElementById('statusTitle');
            const statusDetails = document.getElementById('statusDetails');

            // Show loading state
            statusDiv.className = 'mt-4 p-4 rounded-md bg-blue-50';
            statusIcon.className = 'fas fa-spinner fa-spin text-blue-400';
            statusTitle.textContent = 'Testing Connection...';
            statusDetails.textContent = 'Please wait while we verify your credentials...';
            statusDiv.classList.remove('hidden');

            fetch('/config/test-connection', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    statusDiv.className = 'mt-4 p-4 rounded-md bg-green-50';
                    statusIcon.className = 'fas fa-check-circle text-green-400';
                    statusTitle.textContent = 'Connection Successful';
                    statusDetails.textContent = data.details;
                } else {
                    statusDiv.className = 'mt-4 p-4 rounded-md bg-red-50';
                    statusIcon.className = 'fas fa-exclamation-circle text-red-400';
                    statusTitle.textContent = 'Connection Failed';
                    statusDetails.textContent = data.details;
                }
            })
            .catch(error => {
                statusDiv.className = 'mt-4 p-4 rounded-md bg-red-50';
                statusIcon.className = 'fas fa-exclamation-circle text-red-400';
                statusTitle.textContent = 'Connection Error';
                statusDetails.textContent = 'Failed to test connection. Please try again.';
                console.error('Error:', error);
            });
        }

        // Add a message to the conversation
        function addMessageToConversation(role, content) {
            const conversationContainer = document.getElementById('conversationContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${role === 'user' ? 'justify-end' : 'justify-start'}`;
            
            const messageBubble = document.createElement('div');
            messageBubble.className = `max-w-3xl rounded-lg px-4 py-2 ${
                role === 'user' 
                    ? 'bg-indigo-600 text-white' 
                    : 'bg-gray-100 text-gray-900'
            }`;
            
            if (role === 'assistant') {
                messageBubble.innerHTML = `<div class="prose">${content}</div>`;
            } else {
                messageBubble.textContent = content;
            }
            
            messageDiv.appendChild(messageBubble);
            conversationContainer.appendChild(messageDiv);
            conversationContainer.scrollTop = conversationContainer.scrollHeight;

            // Add to history
            conversationHistory.push({ role, content });
        }

        // Add these new functions for dynamic loading
        function showLoadingState() {
            const loadingState = document.getElementById('loadingState');
            const responseContent = document.getElementById('responseContent');
            if (loadingState) loadingState.classList.remove('hidden');
            if (responseContent) responseContent.classList.add('hidden');
            updateLoadingProgress(0);
        }

        function hideLoadingState() {
            const loadingState = document.getElementById('loadingState');
            const responseContent = document.getElementById('responseContent');
            if (loadingState) loadingState.classList.add('hidden');
            if (responseContent) responseContent.classList.remove('hidden');
        }

        function updateLoadingProgress(progress) {
            const progressBar = document.getElementById('loadingProgress');
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
        }

        function streamResponse(data, container) {
            return new Promise((resolve) => {
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 5;
                    updateLoadingProgress(Math.min(progress, 90));
                    
                    if (progress >= 90) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 100);
            });
        }

        // Update the askQuestion function to use streaming
        async function askQuestion() {
            const queryInput = document.getElementById('queryInput');
            const query = queryInput.value.trim();
            if (!query) return;

            // Add user message to conversation
            addMessageToConversation('user', query);
            queryInput.value = '';

            // Show loading state
            showLoadingState();

            try {
                const response = await fetch('/ask', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: query,
                        context: {
                            history: conversationHistory,
                            currentContext: currentContext
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Full backend response:', data);

                // Stream the response
                await streamResponse(data, document.getElementById('responseContainer'));

                // Update context
                currentContext = {
                    lastAction: data.action,
                    filters: data.filters || {}
                };

                // Add assistant message to conversation
                addMessageToConversation('assistant', data.summary || 'No summary available');

                // Clear previous visualizations
                clearVisualizations();

                // Handle the response based on the action
                if (data.rawResponse) {
                    const dataTable = document.getElementById('dataTable');
                    const visualization = document.getElementById('visualization');

                    // --- GENERIC: Recursively find the first array of objects in rawResponse ---
                    function findFirstArrayOfObjects(obj) {
                        if (!obj) return null;
                        if (Array.isArray(obj) && obj.length > 0 && typeof obj[0] === 'object') {
                            return obj;
                        }
                        if (typeof obj === 'object') {
                            for (const key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    const found = findFirstArrayOfObjects(obj[key]);
                                    if (found) return found;
                                }
                            }
                        }
                        return null;
                    }
                    let displayData = findFirstArrayOfObjects(data.rawResponse);
                    console.log('Display data (generic):', displayData);

                    // Always clear and show the dataTable
                    if (dataTable) {
                        dataTable.innerHTML = '';
                        dataTable.style.display = 'block';
                    }

                    if (!Array.isArray(displayData) || displayData.length === 0 || typeof displayData[0] !== 'object') {
                        if (dataTable) {
                            dataTable.innerHTML = '<div class="text-red-500 p-4 bg-red-50 rounded-md">No tabular data found in response. Showing raw JSON below:</div>';
                            const pre = document.createElement('pre');
                            pre.className = 'bg-gray-100 p-4 rounded text-xs overflow-x-auto mt-2';
                            pre.textContent = JSON.stringify(data.rawResponse, null, 2);
                            dataTable.appendChild(pre);
                        }
                        updateLoadingProgress(100);
                        hideLoadingState();
                        return;
                    }

                    // Stream the table creation
                    const streamTable = async () => {
                        if (dataTable) {
                            try {
                                await createDataTable(displayData);
                                console.log('Table should be visible now');
                            } catch (tableError) {
                                console.error('Error creating table:', tableError);
                                dataTable.innerHTML = '<div class="text-red-500 p-4 bg-red-50 rounded-md">Error displaying data table</div>';
                            }
                        }
                    };

                    // Stream the visualizations
                    const streamVisualizations = async () => {
                        if (visualization && displayData.length > 0) {
                            try {
                                await createVisualizations(displayData);
                                visualization.style.display = 'grid';
                            } catch (vizError) {
                                console.error('Error creating visualizations:', vizError);
                                visualization.innerHTML = '<div class="text-red-500 p-4 bg-red-50 rounded-md">Error creating visualizations</div>';
                                visualization.style.display = 'block';
                            }
                        } else if (visualization) {
                            visualization.style.display = 'none';
                        }
                    };

                    // Execute streaming operations
                    await Promise.all([
                        streamTable(),
                        streamVisualizations()
                    ]);

                    // Show download button if CSV was requested
                    if (query.toLowerCase().includes('csv') && displayData.length > 0) {
                        const downloadSection = document.createElement('div');
                        downloadSection.className = 'mt-4 p-4 bg-gray-50 rounded-lg';
                        
                        const downloadInfo = document.createElement('p');
                        downloadInfo.className = 'text-sm text-gray-600 mb-2';
                        downloadInfo.textContent = `Found ${displayData.length} records. Click below to download as CSV.`;
                        
                        const downloadButton = document.createElement('button');
                        downloadButton.className = 'px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors';
                        downloadButton.innerHTML = '<i class="fas fa-download mr-2"></i>Download CSV';
                        downloadButton.onclick = () => {
                            try {
                                exportToCSV(displayData);
                            } catch (error) {
                                console.error('Error in CSV export:', error);
                                alert('Error exporting to CSV. Please try again.');
                            }
                        };
                        
                        downloadSection.appendChild(downloadInfo);
                        downloadSection.appendChild(downloadButton);
                        document.getElementById('responseContainer').appendChild(downloadSection);
                    }

                    updateLoadingProgress(100);
                    hideLoadingState();
                } else {
                    // If no raw response, show a message
                    const responseContainer = document.getElementById('responseContainer');
                    if (responseContainer) {
                        responseContainer.innerHTML = '<div class="text-gray-700 p-4">No data available to display.</div>';
                    }
                    updateLoadingProgress(100);
                    hideLoadingState();
                }
            } catch (error) {
                console.error('Error:', error);
                let errorMessage = 'An error occurred while processing your request. ';
                
                if (error.message.includes('504')) {
                    errorMessage += 'The request timed out. Please try again with a more specific query or check your network connection.';
                } else if (error.message.includes('401') || error.message.includes('403')) {
                    errorMessage += 'Authentication failed. Please check your API configuration.';
                } else if (error.message.includes('404')) {
                    errorMessage += 'The requested resource was not found. Please check your query.';
                } else {
                    errorMessage += error.message;
                }

                addMessageToConversation('assistant', errorMessage);
                const responseContainer = document.getElementById('responseContainer');
                if (responseContainer) {
                    responseContainer.innerHTML = `<div class="text-red-500 p-4 bg-red-50 rounded-md">${errorMessage}</div>`;
                }
                updateLoadingProgress(100);
                hideLoadingState();
            }
        }

        function clearVisualizations() {
            // Destroy existing charts
            if (severityChart instanceof Chart) {
                severityChart.destroy();
            }
            if (trendChart instanceof Chart) {
                trendChart.destroy();
            }

            // Clear containers
            const severityChartElement = document.getElementById('severityChart');
            const trendChartElement = document.getElementById('trendChart');
            const dataTableElement = document.getElementById('dataTable');
            const visualizationElement = document.getElementById('visualization');

            if (severityChartElement) severityChartElement.innerHTML = '';
            if (trendChartElement) trendChartElement.innerHTML = '';
            if (dataTableElement) {
                dataTableElement.innerHTML = '';
                dataTableElement.style.display = 'none';
            }
            if (visualizationElement) {
                visualizationElement.style.display = 'none';
            }
        }

        function createVisualizations(data) {
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.error('Invalid data for visualization:', data);
                return;
            }

            const severityChartElement = document.getElementById('severityChart');
            const trendChartElement = document.getElementById('trendChart');

            if (!severityChartElement || !trendChartElement) {
                console.error('Chart elements not found');
                return;
            }

            // Extract data for charts
            const severityData = {};
            const trendData = {};

            data.forEach(item => {
                // Severity distribution
                const severity = item.severity || item.severity_level || 'Unknown';
                severityData[severity] = (severityData[severity] || 0) + 1;

                // Trend over time
                const date = new Date(item.created_at || item.discovered_at || item.last_seen || new Date()).toLocaleDateString();
                trendData[date] = (trendData[date] || 0) + 1;
            });

            // Sort trend data by date
            const sortedDates = Object.keys(trendData).sort((a, b) => new Date(a) - new Date(b));
            const sortedTrendData = {};
            sortedDates.forEach(date => {
                sortedTrendData[date] = trendData[date];
            });

            // Create severity chart
            const severityCtx = severityChartElement.getContext('2d');
            severityChart = new Chart(severityCtx, {
                type: 'pie',
                data: {
                    labels: Object.keys(severityData),
                    datasets: [{
                        data: Object.values(severityData),
                        backgroundColor: [
                            '#dc2626', // Critical - Red
                            '#f97316', // High - Orange
                            '#eab308', // Medium - Yellow
                            '#22c55e'  // Low - Green
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Severity Distribution'
                        },
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });

            // Create trend chart
            const trendCtx = trendChartElement.getContext('2d');
            trendChart = new Chart(trendCtx, {
                type: 'line',
                data: {
                    labels: Object.keys(sortedTrendData),
                    datasets: [{
                        label: 'Findings Over Time',
                        data: Object.values(sortedTrendData),
                        borderColor: '#3b82f6',
                        tension: 0.1,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Trend Over Time'
                        },
                        legend: {
                            position: 'bottom'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Count'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function createDataTable(data) {
            console.log('createDataTable called with data:', data); // Debug log

            if (!data || !Array.isArray(data) || data.length === 0) {
                console.error('Invalid data for table:', data);
                throw new Error('No data available to display');
            }

            const tableContainer = document.getElementById('dataTable');
            if (!tableContainer) {
                console.error('Data table container not found');
                throw new Error('Data table container not found');
            }

            console.log('Creating table with data:', data); // Debug log

            // Limit to first 50 rows for performance
            const maxRows = 50;
            const limitedData = data.slice(0, maxRows);

            // Create table wrapper for better visibility
            const tableWrapper = document.createElement('div');
            tableWrapper.className = 'overflow-x-auto border border-gray-200 rounded-lg';
            
            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-gray-200';

            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            headerRow.className = 'bg-gray-50';
            
            // Get all unique keys from the data
            const allKeys = new Set();
            limitedData.forEach(item => {
                if (item && typeof item === 'object') {
                    Object.keys(item).forEach(key => allKeys.add(key));
                }
            });

            if (allKeys.size === 0) {
                console.error('No valid data fields found');
                throw new Error('No valid data fields found');
            }

            // Sort keys for consistent display
            const sortedKeys = Array.from(allKeys).sort();
            console.log('Table columns:', sortedKeys); // Debug log

            // Create header cells
            sortedKeys.forEach(key => {
                const th = document.createElement('th');
                th.className = 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider';
                th.textContent = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create body
            const tbody = document.createElement('tbody');
            tbody.className = 'bg-white divide-y divide-gray-200';
            
            limitedData.forEach((item, index) => {
                if (!item || typeof item !== 'object') {
                    console.warn('Invalid item at index', index, item);
                    return;
                }
                
                const row = document.createElement('tr');
                row.className = index % 2 === 0 ? 'bg-white' : 'bg-gray-50';
                
                sortedKeys.forEach(key => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-500';
                    const value = item[key];
                    
                    // Format the value based on its type
                    if (value === null || value === undefined) {
                        td.textContent = '';
                    } else if (typeof value === 'object') {
                        td.textContent = JSON.stringify(value);
                    } else {
                        td.textContent = value.toString();
                    }
                    
                    row.appendChild(td);
                });
                
                tbody.appendChild(row);
            });
            table.appendChild(tbody);
            tableWrapper.appendChild(table);

            // Clear and update the container
            tableContainer.innerHTML = '';
            tableContainer.appendChild(tableWrapper);
            tableContainer.style.display = 'block';

            // Show a message if not all rows are displayed
            if (data.length > maxRows) {
                const info = document.createElement('div');
                info.className = 'text-xs text-gray-500 mt-2';
                info.textContent = `Showing first ${maxRows} of ${data.length} results. Please refine your query for more specific results.`;
                tableContainer.appendChild(info);
            }

            console.log('Table created successfully'); // Debug log
        }

        function exportToCSV(data) {
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.error('Invalid data for CSV export:', data);
                return;
            }

            try {
                // Flatten nested objects and arrays
                const flattenedData = data.map(item => {
                    const flattened = {};
                    const flatten = (obj, prefix = '') => {
                        for (const key in obj) {
                            if (obj.hasOwnProperty(key)) {
                                const value = obj[key];
                                const newKey = prefix ? `${prefix}_${key}` : key;
                                
                                if (value === null || value === undefined) {
                                    flattened[newKey] = '';
                                } else if (typeof value === 'object') {
                                    if (Array.isArray(value)) {
                                        flattened[newKey] = value.join('; ');
                                    } else {
                                        flatten(value, newKey);
                                    }
                                } else {
                                    flattened[newKey] = value;
                                }
                            }
                        }
                    };
                    flatten(item);
                    return flattened;
                });

                // Get all unique headers
                const headers = new Set();
                flattenedData.forEach(item => {
                    Object.keys(item).forEach(key => headers.add(key));
                });

                // Convert headers to array and sort them
                const headerArray = Array.from(headers).sort();

                // Create CSV content
                const csvContent = [
                    headerArray.join(','),
                    ...flattenedData.map(row => 
                        headerArray.map(header => {
                            const value = row[header];
                            // Handle special characters and formatting
                            if (value === null || value === undefined) {
                                return '""';
                            }
                            const stringValue = String(value);
                            // Escape quotes and wrap in quotes if contains special characters
                            const needsQuotes = stringValue.includes(',') || 
                                              stringValue.includes('"') || 
                                              stringValue.includes('\n') ||
                                              stringValue.includes(';');
                            return needsQuotes 
                                ? `"${stringValue.replace(/"/g, '""')}"`
                                : stringValue;
                        }).join(',')
                    )
                ].join('\n');

                // Create and trigger download
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                link.href = URL.createObjectURL(blob);
                link.download = `tenable_export_${timestamp}.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error exporting to CSV:', error);
                alert('Error exporting to CSV. Please try again or contact support.');
            }
        }

        // Handle Enter key in input
        document.getElementById('queryInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                askQuestion();
            }
        });

        // Clear conversation
        document.getElementById('clearConversation').addEventListener('click', function() {
            conversationHistory = [];
            currentContext = {
                lastAction: null,
                filters: {}
            };
            document.getElementById('conversationContainer').innerHTML = '';
            clearVisualizations();
        });

        // Add event listeners for key inputs
        document.addEventListener('DOMContentLoaded', function() {
            const accessKeyInput = document.getElementById('accessKey');
            const secretKeyInput = document.getElementById('secretKey');

            if (accessKeyInput) {
                accessKeyInput.addEventListener('input', function() {
                    if (this.value !== '********') {
                        this.removeAttribute('data-has-value');
                    }
                });
            }

            if (secretKeyInput) {
                secretKeyInput.addEventListener('input', function() {
                    if (this.value !== '********') {
                        this.removeAttribute('data-has-value');
                    }
                });
            }
        });
    </script>
</body>
</html> 